
server.port = 8090

spring.datasource.url=jdbc:mysql://localhost:3306/topedu
spring.datasource.username=root
spring.datasource.password=2190
spring.jpa.hibernate.ddl-auto=update

spring.application.name= topEducation


# indicar el puerto libre que se utiliza
# server.port = 8090

# conectar a BD
# spring.datasouce.url=jdbc:mysql://localhost:3306/bdtemp   "la ruta y la BD a abrir (bdtemp se llama en el ejemplo del profe deben cambiar)"
# spring.datasource.username=root       "escribir usuario de bd"
# spring.datasouce.password=Chile&2022    "escribir contraseña de bd?"
# spring.jpa.hibernate.ddl-auto=update     "si no existe se crea"


# 1era capa de persistencia es pura interacción con la base de datos, no hay que colocar codígo de servicio en capa de persistencia
# es repositories que interactua con la bd
# tiene que tener entidades para interactuar en entities, se necesitan guardar en bd
# 
# @Data <---
# @NoArgsConstructor <---   lo señalado es de dependencia LONG que ahorra hacer código de constructor y getters y setters
# @AllArgsConstructor <--- 
#
# CrudRepository<UsuarioEntity Long> deja crear el crud, luego solo hay menos código y solo colocar sus propias sentencias sql
# findByXXX lo entiende la dependencia JPA y no es necesario escribirlos desde cero
# 
# 2nda capa de servicios en services solo está la lógica de negocios, se verifican las condiciones
# hace referencia a la clase para usarla @Autowired UsuarioRepository usuarioRepository
# No tiene que tener querys (solo el repository hay querys)
# 
# 3era capa controladores en controllers son los que reciben las peticiones desde un navegador web
# peticiones tipo http, GET, OUT, DELETE, ... e indica que función de la capa servicio lo soluciona
# Tiene @Controller porque es monolitico, tiene la interfaz y todo. @RestController es cuando se usan microservicios
# @RequestMapping indica que se procesan todas las peticiones
# Interactua con la capa de servicios, no repositorio! @AutoService UsuarioService usuarioService;
# 
# cuando escriba la ruta listar se hace el método dentro de listar         (POST es para grabar datos)
# @GetMapping("/listar")
# 
# en index es html, listar manda los datos al index mediante model, que es un intermediario para mandar los datos
# para mostrar en html index
# No hay lógica de negocio, solo recibe datos
#
#
#
# index es html simple, y como se puso el model se pueden usar los atributos en index,
# en <tbody>
# th:each="usuario:${usuario}">   para cada usuario de la lista usuario
# th:text="${usuario.id}"></td> indica que en una columna tiene que estar usuarios
#
# <a class="btn btn-primnary"> href='#' role="button">Editar</a>  crea un botón editar 
#
#
# y esto es la arquitectura por capas

# los entities no es una capa, sino una identidad que puede llamarse desde cualquier lugar e instanciarlo globalmente
#
